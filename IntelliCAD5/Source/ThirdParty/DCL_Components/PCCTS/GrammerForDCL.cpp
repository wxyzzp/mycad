/*
 * A n t l r  T r a n s l a t i o n  H e a d e r
 *
 * Terence Parr, Will Cohen, and Hank Dietz: 1989-1994
 * Purdue University Electrical Engineering
 * With AHPCRC, University of Minnesota
 * ANTLR Version 1.33
 */
#include <stdio.h>
#define ANTLR_VERSION	133
#line 1 "GrammerForDCL.g"
#include "tokens.h"

// Any definitions that you need in the generated files
#include "stdafx.h"
#include "tile.h"
#include "treenode.h" 
#include "fileinfo.h"  
#include "tree.h"
#include "Main.h"
#include "tileattributes.h"
#include "NonDefinedNode.h"  
#include "exceptionmanager.h"
#include "auditlevel.h"
#include "resource.h"
extern Main g_Main;            //global object used in the application

	
#include "AParser.h"
#include "Grammer.h"
#include "DLexerBase.h"
#include "ATokPtr.h"
#ifndef PURIFY
#define PURIFY(r,s)
#endif
#line 45 "GrammerForDCL.g"

#include "stdafx.h"

//files generated by PCCTS included here

#include "dlexerBase.h" 
#include "dlglexer.h"
#include "Atoken.h" 


typedef ANTLRCommonToken antlrtoken;



void
Grammer::program(void)
{
#line 303 "GrammerForDCL.g"
	zzRULE;
#line 305 "GrammerForDCL.g"
	includeStatementList();
#line 306 "GrammerForDCL.g"
	functionList();
#line 306 "GrammerForDCL.g"
	zzmatch(1); labase++;
	 consume();
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd1, 0x1);
}

void
Grammer::includeStatementList(void)
{
#line 309 "GrammerForDCL.g"
	zzRULE;
	if ( (LA(1)==ATRATEOF) ) {
#line 311 "GrammerForDCL.g"
		includeStatement();
#line 311 "GrammerForDCL.g"
		includeStatementList();
	}
	else {
		if ( (setwd1[LA(1)]&0x2) ) {
		}
		else {FAIL(1,err1,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd1, 0x4);
}

void
Grammer::includeStatement(void)
{
#line 315 "GrammerForDCL.g"
	zzRULE;
	ANTLRTokenPtr _t14=NULL;
#line 316 "GrammerForDCL.g"
	zzmatch(ATRATEOF); labase++;
	 consume();
#line 316 "GrammerForDCL.g"
	zzmatch(INCLUDE); labase++;
	 consume();
#line 316 "GrammerForDCL.g"
	{
		while ( (LA(1)==C_COMMENT) ) {
#line 316 "GrammerForDCL.g"
			zzmatch(C_COMMENT); labase++;
			 consume();
		}
	}
#line 316 "GrammerForDCL.g"
	zzmatch(STRING_LITERAL); _t14 = (ANTLRTokenPtr)LT(1);
 labase++;
	
#line 317 "GrammerForDCL.g"
	
	// included files iterates here
	int nDlgFileID;
	if (g_Main.m_DCLParser.HasErrorOccured() == FALSE )
	{
		g_Main.m_DCLParser.DCLParserStartUp(_t14->getText(),&nDlgFileID);
	}
 consume();
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd1, 0x8);
}

void
Grammer::functionList(void)
{
#line 327 "GrammerForDCL.g"
	zzRULE;
	if ( (setwd1[LA(1)]&0x10) ) {
#line 328 "GrammerForDCL.g"
		function();
#line 328 "GrammerForDCL.g"
		functionList();
	}
	else {
		if ( (LA(1)==1)
 ) {
		}
		else {FAIL(1,err2,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd1, 0x20);
}

void
Grammer::function(void)
{
#line 332 "GrammerForDCL.g"
	zzRULE;
#line 333 "GrammerForDCL.g"
	functionStartStatement();
#line 334 "GrammerForDCL.g"
	zzmatch(LCURLY); labase++;
	 consume();
#line 335 "GrammerForDCL.g"
	statementList();
#line 336 "GrammerForDCL.g"
	subBlockList();
#line 337 "GrammerForDCL.g"
	zzmatch(RCURLY); labase++;
	
#line 338 "GrammerForDCL.g"
	if (m_pCurrentTreeNode ) 
	{
		POSITION pos,prevPos1,prevPos2;
		TreeNode *pTreeNode;
		TileAttributes *pTileAttribute;
		CString wszKeyName = "" ;
		CString wszErrorMessage;
		
					// Validation for attribute redundancy.
		pos = lstNodesWithErrors.GetHeadPosition();
		
 					while ( pos )
		{
			prevPos1 = pos;
			pTreeNode = (TreeNode*) lstNodesWithErrors.GetNext(pos);
			prevPos2 = pos;
			pTileAttribute = (TileAttributes*) lstNodesWithErrors.GetNext(pos);
			
						if ( m_pCurrentTreeNode == pTreeNode )
			{
				wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
				AuditLevelProcessor audlvlProc;
				audlvlProc.FormatHintForRedAttr(                                        
				wszErrorInFunc,                       
				pTreeNode->m_Tile,
				pTileAttribute  
				);
				
							lstNodesWithErrors.RemoveAt(prevPos1);
				delete pTileAttribute;
				lstNodesWithErrors.RemoveAt(prevPos2);
				
							}	
		}  
		

		// Validation of non-container widgets containing children.
		pos =   lstNonContianerNodes.GetHeadPosition();
		while ( pos )
		{ 
			prevPos1 = pos;
			pTreeNode = (TreeNode*)lstNonContianerNodes.GetNext(pos);
			if ( m_pCurrentTreeNode == pTreeNode )
			{
				wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
				AuditLevelProcessor audlvlProc(wszErrorInFunc,pTreeNode->m_Tile.get_RenderableTileName(),wszKeyName);
				audlvlProc.FormatErrorMessage(                                        
				IDS_ERROR_HEADER,
				IDS_WIDGET_CANNOT_HAVE_CHILDREN,
				1
				);
				lstNonContianerNodes.RemoveAt(prevPos1);
			}
			
						}
	}
	
	    
 consume();
#line 397 "GrammerForDCL.g"
	includeStatementList();
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd1, 0x40);
}

void
Grammer::subBlockList(void)
{
#line 400 "GrammerForDCL.g"
	zzRULE;
	if ( (setwd1[LA(1)]&0x80) ) {
#line 401 "GrammerForDCL.g"
		subBlock();
#line 401 "GrammerForDCL.g"
		subBlockList();
	}
	else {
		if ( (LA(1)==RCURLY) ) {
		}
		else {FAIL(1,err3,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd2, 0x1);
}

void
Grammer::subBlock(void)
{
#line 405 "GrammerForDCL.g"
	zzRULE;
	if ( (LA(1)==COLON) ) {
#line 407 "GrammerForDCL.g"
		referenceStatement();
#line 408 "GrammerForDCL.g"
		zzmatch(LCURLY); labase++;
		 consume();
#line 409 "GrammerForDCL.g"
		statementList();
#line 410 "GrammerForDCL.g"
		subBlockList();
#line 411 "GrammerForDCL.g"
		zzmatch(RCURLY); labase++;
		
#line 412 "GrammerForDCL.g"
		
		/****************************************************************************************
		*       When this condition is met (rcurly used) , the pCurrentTreeNode is made to point
		*  to its parent.
		*
		*/ 
		
	      //parent node got back here
		if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
		{
			//end of contained tiles,go one level up
			if (m_pCurrentTreeNode ) 
			{
				POSITION pos,prevPos1,prevPos2;
				TreeNode *pTreeNode;
				TileAttributes *pTileAttribute;
				CString wszKeyName = "" ;
				CString wszErrorMessage;
				
                // Validation for attribute redundancy.
				pos = lstNodesWithErrors.GetHeadPosition();
				
 				while ( pos )
				{
					prevPos1 = pos;
					pTreeNode = (TreeNode*) lstNodesWithErrors.GetNext(pos);
					prevPos2 = pos;
					pTileAttribute = (TileAttributes*) lstNodesWithErrors.GetNext(pos);
					
					if ( m_pCurrentTreeNode == pTreeNode )
					{
						wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
						AuditLevelProcessor audlvlProc;
						audlvlProc.FormatHintForRedAttr(                                        
						wszErrorInFunc,                       
						pTreeNode->m_Tile,
						pTileAttribute  
						);
						
						lstNodesWithErrors.RemoveAt(prevPos1);
						delete pTileAttribute;
						lstNodesWithErrors.RemoveAt(prevPos2);
						
						}
				}  
				

				// Validation of non-container widgets containing children.
				pos =   lstNonContianerNodes.GetHeadPosition();
				while ( pos )
				{ 
					prevPos1 = pos;
					pTreeNode = (TreeNode*)lstNonContianerNodes.GetNext(pos);
					if ( m_pCurrentTreeNode == pTreeNode )
					{
						wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
						AuditLevelProcessor audlvlProc(wszErrorInFunc,pTreeNode->m_Tile.get_RenderableTileName(),wszKeyName);
						audlvlProc.FormatErrorMessage(                                        
						IDS_ERROR_HEADER,
						IDS_WIDGET_CANNOT_HAVE_CHILDREN,
						1
						);
						lstNonContianerNodes.RemoveAt(prevPos1);
					}
					
						}
				m_pCurrentTreeNode = m_pCurrentTreeNode->get_Parent();    
			}
			else
			{
				//				goto fail;
			}
			
			
			
		  }
 consume();
#line 490 "GrammerForDCL.g"
		statementList();
	}
	else {
		if ( (setwd2[LA(1)]&0x2) ) {
#line 491 "GrammerForDCL.g"
			specialBlockStatement();
#line 491 "GrammerForDCL.g"
			statementList();
		}
		else {FAIL(1,err4,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd2, 0x4);
}

void
Grammer::specialBlockStatement(void)
{
#line 495 "GrammerForDCL.g"
	zzRULE;
#line 497 "GrammerForDCL.g"
	
	// TBD
	static CString wszBlockName;
	TreeNode *pTempTreeNode = NULL;
	TreeNode *pReferencedTreeNode = NULL;
	int nResult;   
	//error handling to be done here if function start statement added here
	
		  
#line 507 "GrammerForDCL.g"
	{
		ANTLRTokenPtr _t21=NULL;
		if ( (setwd2[LA(1)]&0x8)
 ) {
#line 507 "GrammerForDCL.g"
			zzsetmatch(TILES_set); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
			
#line 507 "GrammerForDCL.g"
			wszBlockName = _t21->getText();   
 consume();
		}
		else {
			if ( (setwd2[LA(1)]&0x10) ) {
#line 508 "GrammerForDCL.g"
				zzsetmatch(BASE_BLOCKS_set); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
				
#line 508 "GrammerForDCL.g"
				wszBlockName = _t21->getText();   
 consume();
			}
			else {
				if ( (LA(1)==IDENT) ) {
#line 509 "GrammerForDCL.g"
					zzmatch(IDENT); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
					
#line 509 "GrammerForDCL.g"
					wszBlockName = _t21->getText();   
 consume();
				}
				else {FAIL(1,err7,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
			}
		}
	}
#line 511 "GrammerForDCL.g"
	zzmatch(SEMI); labase++;
	
#line 512 "GrammerForDCL.g"
	
	/****************************************************************************************
	*       This condition is met when sub-assemblies are used within definitions. 
	*  If the sub-assembly is already defined , it is cloned , otherwise a entry is made to the 
	*  nondefined node list.
	*
	*
	*/ 
	if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
	{    
		// if the  parent node is complete , then check whether it can hold children or else,just clone
		// then validation can be done after the defintion is complete
		if ( m_pCurrentTreeNode->m_bIsComplete == TRUE )
		{			   
			// only if parent node has been completed,otherwise 
			// just add the node , the validation is that case is done after the node is cloned completely
			
			if ( m_pCurrentTreeNode->m_Tile.IsContainer() == FALSE )
			{
				// Error Handling
				
				lstNonContianerNodes.AddTail(m_pCurrentTreeNode);
				
				g_Main.m_DCLParser.set_NonContianerContains();
				

				delete pTempTreeNode;
				// Goto label which takes care of syntax errors.
			}// end of conditon else for bContainer == TRUE
		} // end of condition of for m_bIsComplete == FALSE
		
		// new node created
		pTempTreeNode = new TreeNode ;
		
		// check whether node is referenced 
		nResult = g_Main.m_DCLParser.FindReferencedNode(wszBlockName,1,&pReferencedTreeNode);
		
		// if referenced node found
		if (nResult == SDS_RTNORM) 
		{   
			// if sub-assembly is referenced , then clone the tree 
			// here 0 is passed as second parameter...to state that 
			// attributes have to be replaced if found , or else added 
			pTempTreeNode->CloneTree(pReferencedTreeNode,0);
		}
		else
		{     
			//if sub-assembly is not defined, then add it to the nondefined list 
			NonDefinedNode *pTempNonDefinedNode = new NonDefinedNode(
			m_pFileInfo->get_DCLFileName(),		
			LT(1)->getLine(),
			0,	
			pTempTreeNode,
			wszBlockName); 
			
			//stating the tree node definition is incomplete,since its reference was not found
			pTempTreeNode->m_Tile.AddReferencedTile(wszBlockName);
			pTempTreeNode->set_IsComplete(FALSE);
			
			//add the nondefined node to the list of nondefined nodes
			g_Main.m_DCLParser.AddNonDefinedNode(pTempNonDefinedNode);
			
			/* if any code for
			a) non defined in function startstatement   
			b) in reference statement
			*/
		}
		

		//check whether parent node is container before adding child then
		
			//adding child node to parent
		m_pCurrentTreeNode->AddChild(pTempTreeNode);
		
		}//end of if condition for bErrorChecked == FALSE
	

 consume();
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd2, 0x20);
}

void
Grammer::statementList(void)
{
#line 593 "GrammerForDCL.g"
	zzRULE;
	if ( (setwd2[LA(1)]&0x40) && (LA(2)==EQUALS) ) {
#line 595 "GrammerForDCL.g"
		assignmentStatement();
#line 595 "GrammerForDCL.g"
		zzmatch(SEMI); labase++;
		 consume();
#line 595 "GrammerForDCL.g"
		statementList();
	}
	else {
		if ( (setwd2[LA(1)]&0x80) && (setwd3[LA(2)]&0x1) ) {
		}
		else {FAIL(2,err8,err9,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd3, 0x2);
}

void
Grammer::functionStartStatement(void)
{
#line 601 "GrammerForDCL.g"
	zzRULE;
	ANTLRTokenPtr _t11=NULL;
#line 603 "GrammerForDCL.g"
	
	// variables declared here 
	static CString wszFunctionName,wszTileName;
	TreeNode *pTempTreeNode = NULL,*pDummyTreeNode = NULL;
	int nTreeType;
	if ( (setwd3[LA(1)]&0x4)
 ) {
#line 610 "GrammerForDCL.g"
		zzsetmatch(BASE_BLOCKS_set); _t11 = (ANTLRTokenPtr)LT(1);
 labase++;
		
#line 611 "GrammerForDCL.g"
		
		/****************************************************************************************
		*       This condition creates tree nodes for base block definitions
		*
		*
		*
		*/  
		
		if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
		{
			// root node generation 
			//wszFunctionName = _T("Prototype");
			wszFunctionName     =  _t11->getText();
			
			TreeNode *pTreeNode = new TreeNode;
			
			//set the function name
			pTreeNode->m_Tile.set_FunctionName(wszFunctionName); 
			
			//any block other than a "tile" is a container entity
			if ( wszFunctionName == _T("tile") )
			{
				pTreeNode->m_Tile.set_Container(FALSE) ;
			}
			else
			{
				pTreeNode->m_Tile.set_Container(TRUE) ;
			}
			
			pTreeNode->m_Tile.set_DialogDefinition(FALSE);
			
			//set the renderable property 
			if ( pTreeNode->m_Tile.IsRenderable(wszFunctionName) == TRUE )
			{
				pTreeNode->m_Tile.set_Renderable(TRUE);
			}
			else
			{
				pTreeNode->m_Tile.set_Renderable(FALSE);
			} 
			
			//set renderable tile name 
			if (pTreeNode->m_Tile.IsRenderable(wszFunctionName))
			{
				pTreeNode->m_Tile.set_RenderableTileName(wszFunctionName) ; 
			}
			
				    //for all tiles except dialog
			if (wszFunctionName == _T("dialog"))
			{
				nTreeType =  2;
			}
			else
			{
				nTreeType =  1;
			}              
			
                        
			//set the root node to Tree class member
			//create a new tree   
			Tree *pTree;
			try
			{
				pTree = new Tree(pTreeNode,nTreeType);
			}
			catch(...)
			{
				ThrowCExceptionManager(MEM_ALLOC_FAILED);
			}
			
					
			//add the tree object to file info data member
			try
			{ 
				ASSERT(m_pFileInfo); 
				m_pFileInfo->AddRootNode(pTree);
			}
			catch(CMemoryException mException)
			{
				ThrowCExceptionManager(LIST_INSERT_FAILED);
			}
			
			m_pCurrentTreeNode = pTreeNode;
			
            }// end of condition g_Main.m_DCLParser.HasErrorOccured() == FALSE
 consume();
	}
	else {
		if ( (setwd3[LA(1)]&0x8) ) {
#line 711 "GrammerForDCL.g"
			{
#line 699 "GrammerForDCL.g"
				{
					ANTLRTokenPtr _t31=NULL;
					if ( (LA(1)==IDENT) ) {
#line 699 "GrammerForDCL.g"
						zzmatch(IDENT); _t31 = (ANTLRTokenPtr)LT(1);
 labase++;
						
#line 700 "GrammerForDCL.g"
						
						wszFunctionName  = _t31->getText();
						wszErrorInFunc   = wszFunctionName;
						
		  
 consume();
					}
					else {
						if ( (setwd3[LA(1)]&0x10) ) {
#line 705 "GrammerForDCL.g"
							zzsetmatch(TILES_set); _t31 = (ANTLRTokenPtr)LT(1);
 labase++;
							
#line 706 "GrammerForDCL.g"
							
							wszFunctionName  = _t31->getText();
							wszErrorInFunc   = wszFunctionName;
 consume();
						}
						else {FAIL(1,err10,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
					}
				}
#line 711 "GrammerForDCL.g"
				 pTempTreeNode  = colonStatement( 0 );

#line 713 "GrammerForDCL.g"
				
				
		if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
				{
					// tree nodes generation
					
			//Checking done to verify re-definition
					

					if ( g_Main.m_DCLParser.FindNodeExists(wszFunctionName) == SDS_RTNORM )
					
				{
						
			  	int line = LT(1)->getLine();
						CString wszErrorString,wszLoadResourceString;
						wszLoadResourceString.LoadString(IDS_TILE_REDEFINITION);
						wszErrorString.Format(wszLoadResourceString,m_wszFileName,line,wszFunctionName);
						
//				g_Main.m_DCLParser.LogErrors(wszErrorString);
						g_Main.m_DCLParser.DisplayError(wszErrorString);
						
				//flag set to state error 	        
						g_Main.m_DCLParser.set_ErrorOccured(TRUE);
						delete pTempTreeNode; 
						
				}
					else
					{    // if not already defined
						
				// set the function name
						pTempTreeNode->m_Tile.set_FunctionName(wszFunctionName);
						
				//check whether definition is a tile 
						if (pTempTreeNode->m_Tile.get_TileName() == "dialog") 
						{
							pTempTreeNode->m_Tile.set_DialogDefinition(TRUE) ;
							nTreeType = 0;
						}
						else
						{
							pTempTreeNode->m_Tile.set_DialogDefinition(FALSE);
							nTreeType = 1;
						}
						
				//check whether the defined tile is renderable
						if (pTempTreeNode->m_Tile.IsRenderable(wszFunctionName))
						{
							pTempTreeNode->m_Tile.set_RenderableTileName(wszFunctionName) ; 
						}
						
							
						//point the datamember of tree object to newly created node									
						//create a new tree object 
						Tree *pTree = new Tree(pTempTreeNode,nTreeType); 
						
				//add to the root nodes list
						try
						{ 
							ASSERT(m_pFileInfo); 
							m_pFileInfo->AddRootNode(pTree);
						}
						catch(CMemoryException mException)
						{
							ThrowCExceptionManager(LIST_INSERT_FAILED);
						}
						
				m_pCurrentTreeNode = pTempTreeNode ;
						
				} // end of else for container redefinition
				} // end of condition for g_Main.m_DCLParser.HasErrorOccured() = FALSE
				
    
#line 785 "GrammerForDCL.g"
				{
					while ( (LA(1)==COLON) ) {
#line 785 "GrammerForDCL.g"
						 pTempTreeNode  = colonStatement( 2 );

					}
				}
			}
#line 787 "GrammerForDCL.g"
			
			// deletion / deallocation
		}
		else {FAIL(1,err11,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd3, 0x20);
}

void
Grammer::referenceStatement(void)
{
#line 794 "GrammerForDCL.g"
	zzRULE;
#line 796 "GrammerForDCL.g"
	
	// declarations 
	TreeNode *pTempTreeNode = NULL;
#line 801 "GrammerForDCL.g"
	 pTempTreeNode  = colonStatement( 1 );

#line 802 "GrammerForDCL.g"
	
	
		/***************************************************************************************
	*       This condition is met whenever a tile is referenced.The referenced tile must be
	*  within a tile which is a container.Otherwise an error is written to the error log.
	* 
	*  Here "pTempTreeNode" is mewly created TreeNode returned from the colon(:) statement rule
	*
	*/
	
	if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
	{
		// validation for reference
		
		ASSERT(m_pCurrentTreeNode); 
		
		// check whether the parent node is complete before checking whether 
		// it is a container
		if ( m_pCurrentTreeNode->m_bIsComplete == TRUE )
		{   
			// if parent is container then add the child,or else  
			// write the error to the error log
			if ( m_pCurrentTreeNode->m_Tile.IsContainer())
			{
				m_pCurrentTreeNode->AddChild(pTempTreeNode);
				m_pCurrentTreeNode = pTempTreeNode;
			} 
			else
			{
				// Error Handling
				
				lstNonContianerNodes.AddTail(m_pCurrentTreeNode);  				
				g_Main.m_DCLParser.set_NonContianerContains();
				m_pCurrentTreeNode->AddChild(pTempTreeNode);
				
				m_pCurrentTreeNode = pTempTreeNode;
				
//				delete pTempTreeNode;
				
				} // end of conditon else for bContainer = TRUE
		}   
		else
		{   
			// added the new tree node to the current node, and 
			// make the new node the current node 
			m_pCurrentTreeNode->AddChild(pTempTreeNode);
			m_pCurrentTreeNode = pTempTreeNode;
		}
		
		}//end of conditon for g_Main.m_DCLParser.HasErrorOccured() = FALSE
	
		
	
		  
#line 856 "GrammerForDCL.g"
	{
		while ( (LA(1)==COLON)
 ) {
#line 856 "GrammerForDCL.g"
			 pTempTreeNode  = colonStatement( 2 );

		}
	}
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd3, 0x40);
}

void
Grammer::assignmentStatement(void)
{
#line 861 "GrammerForDCL.g"
	zzRULE;
#line 863 "GrammerForDCL.g"
	
	//declarations
	static CString wszAttributeName;    // used to store the name of the attribute
	static CString wszAttributeValue;   // used to store the value of the attribute
	TileAttributes *pTempTileAttribute; // holds the name,type and value of attribute set  
#line 870 "GrammerForDCL.g"
	{
		ANTLRTokenPtr _t21=NULL;
		if ( (setwd3[LA(1)]&0x80) ) {
#line 870 "GrammerForDCL.g"
			zzsetmatch(ATTRIBUTES_set); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
			
#line 870 "GrammerForDCL.g"
			wszAttributeName = _t21->getText();   
 consume();
		}
		else {
			if ( (LA(1)==IDENT) ) {
#line 871 "GrammerForDCL.g"
				zzmatch(IDENT); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
				
#line 871 "GrammerForDCL.g"
				wszAttributeName = _t21->getText();   
 consume();
			}
			else {FAIL(1,err13,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
		}
	}
#line 873 "GrammerForDCL.g"
	zzmatch(EQUALS); labase++;
	 consume();
#line 874 "GrammerForDCL.g"
	{
		ANTLRTokenPtr _t21=NULL;
		if ( (setwd4[LA(1)]&0x1) ) {
#line 874 "GrammerForDCL.g"
			constantValue( wszAttributeName );
		}
		else {
			if ( (setwd4[LA(1)]&0x2) ) {
#line 875 "GrammerForDCL.g"
				zzsetmatch(ATTRIB_VALUES_set); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
				
#line 876 "GrammerForDCL.g"
				
				if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
				{
					// attributes set here
					wszAttributeValue = _t21->getText();
					pTempTileAttribute = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
					if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
					{
						TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
						lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
						lstNodesWithErrors.AddTail(pTemp);
					} 
					AuditLevelProcessor audlvl;
					TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
					if ( audlvl.CheckForRedundancy(pTemp) == SDS_RTERROR )
					{
						lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
						lstNodesWithErrors.AddTail(pTemp);
					}
					else
					{
						delete pTemp;
					}
					
			
				}
				
		  
 consume();
			}
			else {FAIL(1,err15,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
		}
	}
#line 905 "GrammerForDCL.g"
	
	//deletion carried on here
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd4, 0x4);
}

void
Grammer::constantValue( CString& wszAttributeName )
{
#line 911 "GrammerForDCL.g"
	zzRULE;
#line 912 "GrammerForDCL.g"
	
	// declarations
	static CString wszAttributeValue;      // Used to set the attribute values and passs the
	TileAttributes *pTempTileAttribute;	  // pointer to  a TileAttribute class object.
	
	    
#line 919 "GrammerForDCL.g"
	{
		ANTLRTokenPtr _t21=NULL;
		if ( (LA(1)==INTLIT)
 ) {
#line 919 "GrammerForDCL.g"
			zzmatch(INTLIT); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
			
#line 920 "GrammerForDCL.g"
			
			if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{ 
				// initailization of integer value
				wszAttributeValue = _t21->getText();
				pTempTileAttribute = new TileAttributes(wszAttributeName,_T("1"),wszAttributeValue);
				if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
				{
					g_Main.m_DCLParser.set_HintCount();
					TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("1"),wszAttributeValue);
					lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
					lstNodesWithErrors.AddTail(pTemp);
				}
			}
			
	   
 consume();
		}
		else {
			if ( (LA(1)==REAL_LIT) ) {
#line 937 "GrammerForDCL.g"
				zzmatch(REAL_LIT); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
				
#line 938 "GrammerForDCL.g"
				
				if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
				{
					// initailization of float value
					wszAttributeValue = _t21->getText();
					pTempTileAttribute = new TileAttributes(wszAttributeName,_T("2"),wszAttributeValue);
					if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
					{
						TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("2"),wszAttributeValue);
						lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
						lstNodesWithErrors.AddTail(pTemp);
					}
				}
 consume();
			}
			else {
				if ( (LA(1)==STRING_LITERAL) ) {
#line 953 "GrammerForDCL.g"
					zzmatch(STRING_LITERAL); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
					
#line 954 "GrammerForDCL.g"
					
					if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
					{
						// initialization of string value  
						wszAttributeValue = _t21->getText();
						pTempTileAttribute = new TileAttributes(wszAttributeName,_T("3"),wszAttributeValue);
						ASSERT(pTempTileAttribute);
						if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
						{
							TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("3"),wszAttributeValue);
							lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
							lstNodesWithErrors.AddTail(pTemp);
						}
						

					}
					
	    
 consume();
				}
				else {
					if ( (LA(1)==IDENT) ) {
#line 973 "GrammerForDCL.g"
						zzmatch(IDENT); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
						
#line 974 "GrammerForDCL.g"
						
						if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
						{ 
							// initialization of identifier value  
							wszAttributeValue = _t21->getText();
							pTempTileAttribute = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
							ASSERT(pTempTileAttribute);
							if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
							{
								TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
								lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
								lstNodesWithErrors.AddTail(pTemp);
							}
						}
						
		  
 consume();
					}
					else {FAIL(1,err16,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
				}
			}
		}
	}
#line 992 "GrammerForDCL.g"
	
	// deletion
	return;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd4, 0x8);
}

 TreeNode *  
Grammer::colonStatement( int nOccurance )
{
	 TreeNode *  	 _retv;
	PURIFY(_retv,sizeof( TreeNode *  	))
#line 997 "GrammerForDCL.g"
	zzRULE;
#line 999 "GrammerForDCL.g"
	
	// declarations
	static CString wszTileName;     // holds the tile name
	Tile *pTile = NULL;             // holds the pointer to the referenced tile
	TreeNode *pTempTreeNode = NULL ;    // holds the pointer to a node created
	TreeNode *pReferencedNode = NULL;   //points to the node being referenced  
	int nResult = 0;                    // to store return value of functions  
	
		  
#line 1009 "GrammerForDCL.g"
	zzmatch(COLON); labase++;
	 consume();
#line 1010 "GrammerForDCL.g"
	{
		ANTLRTokenPtr _t21=NULL;
		if ( (setwd4[LA(1)]&0x10) ) {
#line 1010 "GrammerForDCL.g"
			zzsetmatch(TILES_set); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
			
#line 1010 "GrammerForDCL.g"
			wszTileName = _t21->getText();   
 consume();
		}
		else {
			if ( (LA(1)==IDENT)
 ) {
#line 1011 "GrammerForDCL.g"
				zzmatch(IDENT); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
				
#line 1011 "GrammerForDCL.g"
				wszTileName = _t21->getText();   
 consume();
			}
			else {
				if ( (setwd4[LA(1)]&0x20) ) {
#line 1012 "GrammerForDCL.g"
					zzsetmatch(BASE_BLOCKS_set); _t21 = (ANTLRTokenPtr)LT(1);
 labase++;
					
#line 1012 "GrammerForDCL.g"
					wszTileName = _t21->getText();   
 consume();
				}
				else {FAIL(1,err17,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
			}
		}
	}
#line 1014 "GrammerForDCL.g"
	
	/****************************************************************************************
	*       This condition is called whenever a  " :reference " statement is found.
	*  It accepts a input value  
	*   0 - when condition called from protypes
	*   1 - when condition called from reference statements
	*   2 - for multiple references 
	*/  
	
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
	{	
		// tree generation
		_retv = NULL ;
		nResult = SDS_RTNORM;
		
			//find reference and clone the node if reference is in the first level
		if ( nOccurance == 1 ||  nOccurance == 0) 
		{
			if (wszTileName == _T("dialog"))
			{
				nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,2,&pReferencedNode);
			}
			else
			{ 
				nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,1,&pReferencedNode);
			}
		}
		
			//if reference found
		if (nResult == SDS_RTNORM) 
		{
			if ( nOccurance == 1 ||  nOccurance == 0) 
			{ 
				pTempTreeNode = new TreeNode ;
				
					if (pTempTreeNode->m_Tile.IsRenderable(wszTileName))
				{
					pTempTreeNode->m_Tile.set_RenderableTileName(wszTileName) ; 
				}
				
					pTempTreeNode->m_Tile.set_TileName(wszTileName);  				
				
					pTempTreeNode->m_Tile.CopyAttributes(wszErrorInFunc,pReferencedNode->m_Tile,0); 
				_retv = pTempTreeNode ;
			} 
			else if  (  nOccurance == 2 ) //this condition met for multiple reference
			{
				// code for multiple references 
				
					//add referenced tile to list
				m_pCurrentTreeNode->m_Tile.AddReferencedTile(wszTileName);
				if ( m_pCurrentTreeNode->m_Tile.GetTileNameToBeCloned() == wszTileName ) 
				{												
					if (wszTileName == _T("dialog"))
					{  
						nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,2,&pReferencedNode);
					}
					else 
					{  
						nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,1,&pReferencedNode);
					}
				}
				else  
				{
					nResult = SDS_RTERROR;
				}
				
       
				//if reference found
				if ( nResult == SDS_RTNORM )
				{
					ASSERT(m_pCurrentTreeNode);
					m_pCurrentTreeNode->m_Tile.CopyAttributes(wszErrorInFunc,pReferencedNode->m_Tile,2);
				}
				else
				{
					
						//if	reference not found then add to non-defined list
					NonDefinedNode *pTempNonDefinedNode = new NonDefinedNode(
					m_pFileInfo->get_DCLFileName(),		
					LT(1)->getLine(),
					2,
					m_pCurrentTreeNode,
					wszTileName);				
					

					//add the nondefined node to the list of nondefined nodes
					g_Main.m_DCLParser.AddNonDefinedNode(pTempNonDefinedNode);
					
						/* if any code for
					a) non defined in function startstatement   
					b) in reference statement
					*/	
					
						}     
				
					}//end of else if  for $nOccurance == 2
		}//end of condition for nResult == SDS_RTNORM 
		else
		{
			//add code for undefined nodes
			pTempTreeNode = new TreeNode ; 	 
			pTempTreeNode->m_Tile.AddReferencedTile(wszTileName);
			pTempTreeNode->m_Tile.set_TileName(wszTileName);
			_retv = pTempTreeNode ;
			
				NonDefinedNode *pTempNonDefinedNode = new NonDefinedNode(
			m_pFileInfo->get_DCLFileName(),		 
			LT(1)->getLine(),
			1,
			pTempTreeNode,
			wszTileName);
			
				pTempTreeNode->m_bIsComplete = FALSE;
			

			//add the nondefined node to the list of nondefined nodes
			g_Main.m_DCLParser.AddNonDefinedNode(pTempNonDefinedNode);
			
				/* if any code for
			a) non defined in function startstatement   
			b) in reference statement
			*/
			
				_retv = pTempTreeNode ;
		}//end of condtion for nondefined node
		
			}//end of condition for g_Main.m_DCLParser.HasErrorOccured() == FALSE		         
	
	    
#line 1145 "GrammerForDCL.g"
	
	// delete
	
	    
	return _retv;
fail:
	syn(zzBadTok, (ANTLRChar *)"", zzMissSet, zzMissTok, zzErrk);
	resynch(setwd4, 0x40);
	return _retv;
}
