/* FILENAME:     GrammerForDCL.g- Contains implementation Grammer for DCL.
* Copyright  (C) Copyright 1998  Visio Corporation.  All Rights Reserved.
*
*
*
* Abstract 
*     This file implemnents the grammer to be followed by the DCL files.  This file has an 
*     implementation of Grammer class in which all the rules are implemented.
*     The PCCTS application uses this grammer file to generate a host of files.
*     The custom  compiler settings used for this file are
*      
*     antlr.exe -CC -gl  -k 2 GrammerForDCL.g  
*     dlg.exe -CC  parser.dlg
*
*     
* Audit Log 
*
*
* Audit Trail
*
*
*/

#header 
<<
    // Any definitions that you need in the generated files
	#include "stdafx.h"
	#include "tile.h"
	#include "treenode.h" 
	#include "fileinfo.h"  
	#include "tree.h"
	#include "Main.h"
	#include "tileattributes.h"
	#include "NonDefinedNode.h"  
	#include "exceptionmanager.h"
	#include "auditlevel.h"
	#include "resource.h"
	extern Main g_Main;            //global object used in the application

	
>>

// Scanner rules

<<
#include "stdafx.h"

//files generated by PCCTS included here

#include "dlexerBase.h" 
#include "dlglexer.h"
#include "Atoken.h" 


typedef ANTLRCommonToken antlrtoken;


>>

#lexclass START 

// White Space
#token WHITE_SPACE  "[\ \t\r]"   <<skip();>>
#token "\n"           <<skip(); newline();>>
#token "\0" <<skip();>>

// C style comments
#token C_COMMENT  "/ \*" <<skip(); mode(C_STYLE_COMMENT);>>

// C++ style Comments
#token "// ~[\n@]* [\n@]" <<skip(); newline();>>

// Literals
#token INTLIT  "{[\-\+]} [0-9]+"
#token REAL_LIT   "{[\-\+]} [0-9]+ [0-9]*.[0-9]+ [0-9]*" 


#token   "\"" 
				<< 
					// start STRINGLIT
                    skip();
                    mode(STRING);
                >>


// KEYWORDS

// Names of pre-defined tiles
#token BOXED_COLUMN  "boxed_column"
#token BOXED_RADIO_COLUMN  "boxed_radio_column"
#token BOXED_RADIO_ROW  "boxed_radio_row"
#token BOXED_ROW "boxed_row"
#token BUTTON    "button"
#token COLUMN   "column"
#token CONCATENATION "concatenation"
#token CLUSTER    "cluster"
#token DIALOG  "dialog"
#token EDIT_BOX      "edit_box"
#token ERRTILE "errtile"
#token IMAGE  "image"
#token IMAGE_BUTTON "image_button"
#token LIST_BOX  "list_box"
#token OK_CANCEL_HELP_ERRTILE    "ok_cancel_help_errtile"
#token OK_CANCEL  "ok_cancel"
#token OK_ONLY   "ok_only"
#token OK_CANCEL_HELP  "ok_cancel_help"
#token OK_CANCEL_HELP_INFO "ok_cancel_help_info"
#token PARAGRAPH "paragraph"
#token POPUP_LIST     "popup_list"
#token ROW        "row"
#token RADIO_CLUSTER "radio_cluster"
#token RADIO_ROW   "radio_row"
#token RADIO_COLUMN   "radio_column"
#token RADIO_BUTTON   "radio_button"
#token SLIDER  "slider"
#token SPACER "spacer"
#token SPACER_0 "spacer_0"
#token SPACER_1 "spacer_1"
#token TOGGLE   "toggle"
#token TEXT		"text"
#token TEXT_PART "text_part"
#token TILE       "tile"

// Attribute names
#token ACTION       "action"
#token ALIGNMENT  "alignment"
#token ALLOW_ACCEPT   "allow_accept"
#token ASPECT_RATIO "aspect_ratio"
#token BIG_INCREMENT   "big_increment"
#token CHILDREN_ALIGNMENT     "children_alignment"
#token CHILDREN_FIXED_HEIGHT     "children_fixed_height"
#token CHILDREN_FIXED_WIDTH   "children_fixed_width"
#token COLOR   "color"
#token EDIT_LIMIT        "edit_limit"
#token EDIT_WIDTH      "edit_width"
#token FIXED_HEIGHT     "fixed_height"
#token FIXED_WIDTH     "fixed_width"
#token HEIGHT     "height"
#token IS_BOLD      "is_bold"
#token IS_CANCEL       "is_cancel"
#token IS_DEFAULT        "is_default"
#token IS_ENABLED   "is_enabled"
#token IS_TAB_STOP  "is_tab_stop"
#token INITIAL_FOCUS   "initial_focus"
#token KEY   "key"
#token LABEL   "label"
#token LAYOUT  "layout"
#token LIST   "list"
#token MNEMONIC   "mnemonic"
#token MIN_VALUE  "min_value"
#token MAX_VALUE  "max_value"
#token MULTIPLE_SELECT "multiple_select"
#token PASSWORD_CHAR   "password_char"
#token SMALL_INCREMENT   "small_increment"
#token TABS   "tabs"
#token VALUE   "value"
#token WIDTH   "width"
#token FIXED_WIDTH_FONT   "fixed_width_font"
#token TAB_TRUNCATE "tab_truncate"

// Pre-defined attribute values
#token TRUVAL	 "true"
#token FALSEVAL  "false"
#token NONEVAL "none"
#token LEFT	   "left"
#token RIGHT   "right"
#token TOP  "top"
#token BOTTOM "bottom"
#token CENTERED  "centered"	
#token HORIZONTAL	"horizontal"	 	
#token VERTICAL		"vertical"

// Operators
#token COLON      ":"
#token SEMI       ";"
#token EQUALS     "="
#token LCURLY     "\{"
#token RCURLY     "\}"
#token ATRATEOF   "\@"
#token INCLUDE    "include"


// Identifiers
#token IDENT "[a-zA-Z_] [a-zA-Z0-9_]*" 


#lexclass C_STYLE_COMMENT
#token "[\n\r]"      << skip(); newline(); >>
#token "\*/"         << mode (START); skip (); >>
#token "\*"          << skip (); >>
#token "~[\*\n\r]+"  << skip (); >>


// String Literal Processing
// Separate Scanner class

#lexclass STRING

#token  "\"\"" <<
                  more();
                  replchar('\"');
               >>
#token "\\n" << replchar ((char) 0x2C); more (); >>
#token "\\t" << replchar ((char) 0x09); more (); >>
#token "\\v" << replchar ((char) 0x0B); more (); >>
#token "\\b" << replchar ((char) 0x08); more (); >>
#token "\\r" << replchar ((char) 0x0D); more (); >>
#token "\\u" << replchar ((char) 0x1F); more (); >>  // underscore
#token "\\a" << replchar ((char) 0x07); more (); >>
#token "\\\\" << replchar ((char) 0x5C); more (); >>
#token "\\?" << replchar ((char) 0x3F); more (); >>
#token "\\'" << replchar ((char) 0x27); more (); >>
#token "\\\"" << replchar ((char) 0x22); more (); >>
#token "\ " << replchar ((char) 0x20); more (); >>
#token "\(" << replchar ((char) 0x28); more (); >>
#token "\)" << replchar ((char) 0x29); more (); >>
//#token "[\n \r]" << newline(); replchar ((char) 0x20); more (); >>
#token BADSTRING "\n"    <<  
		                     replchar('\0'); 
                             newline(); 
                             mode(START);
                             /* error message */                          
							 >>

// EBATECH(CNBR) -[ Bugzilla#78272
// Recoginize Multibyte Charactor as one charactor.
// Uncomment one of target code system.

// Japanese (dos932/shiftjis/ANSI_932)
//#token "[\0x81-\0x9F]~[]" << more(); >>
//#token "[\0xE0-\0xFE]~[]" << more(); >>

// Traditional Chinese (big5/ANSI_950)
//#token "[\0x81-\0xFE]~[]" << more(); >>

// Simplified Chinese (gb2312/ANSI_936)
//#token "[\0xA1-\0xFE]~[]" << more(); >>

// Windows Korean (johab/ANSI_1361)
//#token "[\0x84-\0xD3]~[]" << more(); >>

// DOS Korean (ksc5601/ANSI_949)
//#token "[\0x81-\0xFE]~[]" << more(); >>

// EBATECH(CNBR) ]-

#token STRING_LITERAL "\"" <<
                             // truncate quote
                             replchar('\0');
                             mode(START);
                         >>

#token           "~[]"  <<
							// Any other char, add to token
							more();
						>>

// Names of pre-defined attributes
#tokclass ATTRIBUTES  
{ 
    ACTION   ALIGNMENT  ALLOW_ACCEPT ASPECT_RATIO 
	BIG_INCREMENT  CHILDREN_ALIGNMENT  CHILDREN_FIXED_HEIGHT  
	CHILDREN_FIXED_WIDTH  COLOR  EDIT_LIMIT  EDIT_WIDTH  
	FIXED_HEIGHT  FIXED_WIDTH  FIXED_WIDTH_FONT HEIGHT 
	IS_BOLD  IS_CANCEL IS_DEFAULT IS_ENABLED  INITIAL_FOCUS 
	IS_TAB_STOP KEY LABEL  LAYOUT LIST  MNEMONIC  MIN_VALUE 
	MAX_VALUE  MULTIPLE_SELECT PASSWORD_CHAR SMALL_INCREMENT  
	TABS  TAB_TRUNCATE VALUE  WIDTH   
}      


// Names of pre-defined tiles
#tokclass TILES 
{
   BUTTON  EDIT_BOX  IMAGE IMAGE_BUTTON  LIST_BOX PARAGRAPH 
   POPUP_LIST RADIO_BUTTON SPACER  SPACER_0  SPACER_1  SLIDER 
   TEXT   TEXT_PART   TOGGLE 	       
   // part of Special_blocks earlier
   OK_ONLY ERRTILE  
   // Part of TILE_COLLECTION before
   BOXED_COLUMN  BOXED_RADIO_COLUMN  BOXED_RADIO_ROW  BOXED_ROW  
   COLUMN  CONCATENATION RADIO_ROW  RADIO_COLUMN ROW 
   // part of Special_blocks earlier
   OK_CANCEL  OK_CANCEL_HELP OK_CANCEL_HELP_INFO OK_CANCEL_HELP_ERRTILE  
}

// Pre-defined values for certain attributes
#tokclass ATTRIB_VALUES 
{
    TRUVAL   FALSEVAL  NONEVAL LEFT	RIGHT  CENTERED	TOP BOTTOM
	VERTICAL HORIZONTAL
}	

#tokclass BASE_BLOCKS
{
	DIALOG	CLUSTER	  TILE   RADIO_CLUSTER	 
}

class Grammer
{
<<
	 // Parser definitions go here
            	
	public:
    
		 // Global variables while parsing

		 FileInfo *m_pFileInfo;                // Used to hold the info regarding which file is being parsed
		 TreeNode *m_pCurrentTreeNode;         // Used to keep track of nodes added during tree node
		 CString wszErrorInFunc ;              // Used for formatting error messages. 
		 CString wszErrorInWidget;             // Used for formatting error messages. 
		 CObList lstNodesWithErrors;           // Used for stacking nodes with redundant assignments(used for hinting in audit level 3).
		 CObList lstNonContianerNodes;         // Used to contain stack the nodes which cannot have children.
		 		     
		 void init()
			{   
		    ANTLRParser::init(m_pFileInfo->get_DCLFileName());
			// Any specific initialization you need
            // (if none, don't override the init() method
			}
>>

program 
	: 
	 includeStatementList 
	 functionList  "@"  //End of file	
	 ;

includeStatementList
	: 
	 includeStatement includeStatementList
	 |  // Nothing
	;
	
includeStatement
	: ATRATEOF INCLUDE (C_COMMENT)* STRING_LITERAL
		<<
		// included files iterates here
		     int nDlgFileID;
             if (g_Main.m_DCLParser.HasErrorOccured() == FALSE )
				{
				g_Main.m_DCLParser.DCLParserStartUp($4->getText(),&nDlgFileID);
				}
		>>
	;
		
functionList 
	: function functionList 
	|  // Nothing
	;

function
	: functionStartStatement   // Create new parse tree here
	  LCURLY  
      statementList	// Store attribute names & values in current parent here
	  subBlockList				  
	  RCURLY  
	  <<		if (m_pCurrentTreeNode ) 
					{
					POSITION pos,prevPos1,prevPos2;
					TreeNode *pTreeNode;
					TileAttributes *pTileAttribute;
					CString wszKeyName = "" ;
					CString wszErrorMessage;

					// Validation for attribute redundancy.
					pos = lstNodesWithErrors.GetHeadPosition();

 					while ( pos )
						{
						prevPos1 = pos;
						pTreeNode = (TreeNode*) lstNodesWithErrors.GetNext(pos);
						prevPos2 = pos;
						pTileAttribute = (TileAttributes*) lstNodesWithErrors.GetNext(pos);

						if ( m_pCurrentTreeNode == pTreeNode )
							{
							wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
							AuditLevelProcessor audlvlProc;
							audlvlProc.FormatHintForRedAttr(                                        
											  wszErrorInFunc,                       
											  pTreeNode->m_Tile,
											  pTileAttribute  
											  );
	
							lstNodesWithErrors.RemoveAt(prevPos1);
							delete pTileAttribute;
							lstNodesWithErrors.RemoveAt(prevPos2);
                        
							}	
						}  


					// Validation of non-container widgets containing children.
					pos =   lstNonContianerNodes.GetHeadPosition();
					while ( pos )
						{ 
						prevPos1 = pos;
						pTreeNode = (TreeNode*)lstNonContianerNodes.GetNext(pos);
						if ( m_pCurrentTreeNode == pTreeNode )
							{
							wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
							AuditLevelProcessor audlvlProc(wszErrorInFunc,pTreeNode->m_Tile.get_RenderableTileName(),wszKeyName);
							audlvlProc.FormatErrorMessage(                                        
											  IDS_ERROR_HEADER,
											  IDS_WIDGET_CANNOT_HAVE_CHILDREN,
											  1
											  );
							lstNonContianerNodes.RemoveAt(prevPos1);
							}
                        
						}
				   }
				
	  >>

	  includeStatementList
	  ;

subBlockList
	: subBlock	subBlockList
	|  // Nothing
	;

subBlock			  
	: // Syntactic predicate to resolve ambiguity
	  referenceStatement  
	  LCURLY  
	  statementList
	  subBlockList  
	  RCURLY 
	  <<	  
	      /****************************************************************************************
		  *       When this condition is met (rcurly used) , the pCurrentTreeNode is made to point
          *  to its parent.
		  *
		  */ 

	      //parent node got back here
		  if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
			{
		    //end of contained tiles,go one level up
			if (m_pCurrentTreeNode ) 
				{
				POSITION pos,prevPos1,prevPos2;
				TreeNode *pTreeNode;
				TileAttributes *pTileAttribute;
				CString wszKeyName = "" ;
				CString wszErrorMessage;

                // Validation for attribute redundancy.
				pos = lstNodesWithErrors.GetHeadPosition();

 				while ( pos )
					{
					prevPos1 = pos;
					pTreeNode = (TreeNode*) lstNodesWithErrors.GetNext(pos);
					prevPos2 = pos;
					pTileAttribute = (TileAttributes*) lstNodesWithErrors.GetNext(pos);

					if ( m_pCurrentTreeNode == pTreeNode )
						{
						wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
						AuditLevelProcessor audlvlProc;
						audlvlProc.FormatHintForRedAttr(                                        
											  wszErrorInFunc,                       
											  pTreeNode->m_Tile,
											  pTileAttribute  
											  );
	
						lstNodesWithErrors.RemoveAt(prevPos1);
						delete pTileAttribute;
						lstNodesWithErrors.RemoveAt(prevPos2);
                        
						}
					}  


                    // Validation of non-container widgets containing children.
					pos =   lstNonContianerNodes.GetHeadPosition();
					while ( pos )
						{ 
						prevPos1 = pos;
						pTreeNode = (TreeNode*)lstNonContianerNodes.GetNext(pos);
						if ( m_pCurrentTreeNode == pTreeNode )
							{
							wszKeyName = (pTreeNode->m_Tile.get_ListOfAttributes())->get_Key();
							AuditLevelProcessor audlvlProc(wszErrorInFunc,pTreeNode->m_Tile.get_RenderableTileName(),wszKeyName);
							audlvlProc.FormatErrorMessage(                                        
											  IDS_ERROR_HEADER,
											  IDS_WIDGET_CANNOT_HAVE_CHILDREN,
											  1
											  );
							lstNonContianerNodes.RemoveAt(prevPos1);
							}
                        
						}
				m_pCurrentTreeNode = m_pCurrentTreeNode->get_Parent();    
				}
			else
				{
//				goto fail;
				}
            
			

		  }
      >>
	  // Store attribute names & values in current parent here	
	  statementList 
	|specialBlockStatement statementList
	;


specialBlockStatement
	:
		<<	
		   // TBD
		   static CString wszBlockName;
           TreeNode *pTempTreeNode = NULL;
           TreeNode *pReferencedTreeNode = NULL;
		   int nResult;   
		   //error handling to be done here if function start statement added here

		>>

	 (TILES  << wszBlockName = $1->getText(); >>
	 | BASE_BLOCKS 	<< wszBlockName = $1->getText(); >>
	 |IDENT	<< wszBlockName = $1->getText(); >>
     )	
	 SEMI	 
	  <<      
		  /****************************************************************************************
		  *       This condition is met when sub-assemblies are used within definitions. 
          *  If the sub-assembly is already defined , it is cloned , otherwise a entry is made to the 
		  *  nondefined node list.
		  *
		  *
		  */ 
	if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
		{    
	    // if the  parent node is complete , then check whether it can hold children or else,just clone
		// then validation can be done after the defintion is complete
		if ( m_pCurrentTreeNode->m_bIsComplete == TRUE )
			{			   
			// only if parent node has been completed,otherwise 
			// just add the node , the validation is that case is done after the node is cloned completely
               
			if ( m_pCurrentTreeNode->m_Tile.IsContainer() == FALSE )
				{
				// Error Handling

				lstNonContianerNodes.AddTail(m_pCurrentTreeNode);
				
				g_Main.m_DCLParser.set_NonContianerContains();
              

				delete pTempTreeNode;
				// Goto label which takes care of syntax errors.
				}// end of conditon else for bContainer == TRUE
		} // end of condition of for m_bIsComplete == FALSE

		// new node created
		pTempTreeNode = new TreeNode ;
	
		// check whether node is referenced 
		nResult = g_Main.m_DCLParser.FindReferencedNode(wszBlockName,1,&pReferencedTreeNode);

		// if referenced node found
		if (nResult == SDS_RTNORM) 
			{   
			// if sub-assembly is referenced , then clone the tree 
			// here 0 is passed as second parameter...to state that 
			// attributes have to be replaced if found , or else added 
			pTempTreeNode->CloneTree(pReferencedTreeNode,0);
			}
		else
			{     
			//if sub-assembly is not defined, then add it to the nondefined list 
        	NonDefinedNode *pTempNonDefinedNode = new NonDefinedNode(
																 m_pFileInfo->get_DCLFileName(),		
			                                                     LT(1)->getLine(),
																 0,	
																 pTempTreeNode,
                                                                 wszBlockName); 
						
			//stating the tree node definition is incomplete,since its reference was not found
			pTempTreeNode->m_Tile.AddReferencedTile(wszBlockName);
			pTempTreeNode->set_IsComplete(FALSE);
						    
			//add the nondefined node to the list of nondefined nodes
			g_Main.m_DCLParser.AddNonDefinedNode(pTempNonDefinedNode);

			/* if any code for
					    a) non defined in function startstatement   
						b) in reference statement
						*/
			}
		        

			//check whether parent node is container before adding child then

			//adding child node to parent
			m_pCurrentTreeNode->AddChild(pTempTreeNode);
			   
		}//end of if condition for bErrorChecked == FALSE


	  >> 

	;

statementList			 
	: 	
	 assignmentStatement  SEMI statementList
	| // Nothing
	;



functionStartStatement 
     :
	  << 
         // variables declared here 
		static CString wszFunctionName,wszTileName;
		TreeNode *pTempTreeNode = NULL,*pDummyTreeNode = NULL;
		int nTreeType;
	  >>

	 BASE_BLOCKS  // No user-defined tile may be defined as a Base_block
	  <<  
	      /****************************************************************************************
		  *       This condition creates tree nodes for base block definitions
		  *
		  *
		  *
		  */  

		if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
			{
    		// root node generation 
			//wszFunctionName = _T("Prototype");
			wszFunctionName     =  $1->getText();
             					
			TreeNode *pTreeNode = new TreeNode;
	
			//set the function name
			pTreeNode->m_Tile.set_FunctionName(wszFunctionName); 
	
			//any block other than a "tile" is a container entity
			if ( wszFunctionName == _T("tile") )
				{
				pTreeNode->m_Tile.set_Container(FALSE) ;
				}
			else
				{
				pTreeNode->m_Tile.set_Container(TRUE) ;
				}

			pTreeNode->m_Tile.set_DialogDefinition(FALSE);
            
			//set the renderable property 
			if ( pTreeNode->m_Tile.IsRenderable(wszFunctionName) == TRUE )
				{
				pTreeNode->m_Tile.set_Renderable(TRUE);
				}
			else
				{
				pTreeNode->m_Tile.set_Renderable(FALSE);
                } 

			//set renderable tile name 
			if (pTreeNode->m_Tile.IsRenderable(wszFunctionName))
				{
		  		pTreeNode->m_Tile.set_RenderableTileName(wszFunctionName) ; 
				}

				    //for all tiles except dialog
			if (wszFunctionName == _T("dialog"))
				{
				nTreeType =  2;
			    }
			else
				{
				nTreeType =  1;
				}              

                        
			//set the root node to Tree class member
			//create a new tree   
			Tree *pTree;
			try
				{
				pTree = new Tree(pTreeNode,nTreeType);
				}
            catch(...)
				{
				ThrowCExceptionManager(MEM_ALLOC_FAILED);
				}
			           
					
			//add the tree object to file info data member
			try
				{ 
				ASSERT(m_pFileInfo); 
				m_pFileInfo->AddRootNode(pTree);
				}
			catch(CMemoryException mException)
				{
				ThrowCExceptionManager(LIST_INSERT_FAILED);
				}

			m_pCurrentTreeNode = pTreeNode;
              
            }// end of condition g_Main.m_DCLParser.HasErrorOccured() == FALSE
     >>  	  
	  
	 |(
	    (IDENT 
		<<
		    wszFunctionName  = $1->getText();
			wszErrorInFunc   = wszFunctionName;
		    
		>> 
	    |TILES
		<<  
		    wszFunctionName  = $1->getText();
		    wszErrorInFunc   = wszFunctionName;
		>> 
		)
		colonStatement[0] >[pTempTreeNode]
	    // Create new node (this is root for the current parse tree)	 
	    <<	    
		   
		if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
			{
			// tree nodes generation
		   
			//Checking done to verify re-definition
            

            if ( g_Main.m_DCLParser.FindNodeExists(wszFunctionName) == SDS_RTNORM )

				{

			  	int line = LT(1)->getLine();
				CString wszErrorString,wszLoadResourceString;
                wszLoadResourceString.LoadString(IDS_TILE_REDEFINITION);
                wszErrorString.Format(wszLoadResourceString,m_wszFileName,line,wszFunctionName);
							
//				g_Main.m_DCLParser.LogErrors(wszErrorString);
                g_Main.m_DCLParser.DisplayError(wszErrorString);
	            
				//flag set to state error 	        
	   			g_Main.m_DCLParser.set_ErrorOccured(TRUE);
				delete pTempTreeNode; 
				
				}
			else
				{    // if not already defined
						    
				// set the function name
				pTempTreeNode->m_Tile.set_FunctionName(wszFunctionName);
							
				//check whether definition is a tile 
				if (pTempTreeNode->m_Tile.get_TileName() == "dialog") 
					{
					pTempTreeNode->m_Tile.set_DialogDefinition(TRUE) ;
					nTreeType = 0;
					}
				else
					{
					pTempTreeNode->m_Tile.set_DialogDefinition(FALSE);
					nTreeType = 1;
					}
            
				//check whether the defined tile is renderable
				if (pTempTreeNode->m_Tile.IsRenderable(wszFunctionName))
					{
		  			pTempTreeNode->m_Tile.set_RenderableTileName(wszFunctionName) ; 
					}

							
				//point the datamember of tree object to newly created node									
				//create a new tree object 
				Tree *pTree = new Tree(pTempTreeNode,nTreeType); 
            
				//add to the root nodes list
				try
					{ 
					ASSERT(m_pFileInfo); 
					m_pFileInfo->AddRootNode(pTree);
					}
				catch(CMemoryException mException)
					{
					ThrowCExceptionManager(LIST_INSERT_FAILED);
					}

				m_pCurrentTreeNode = pTempTreeNode ;

				} // end of else for container redefinition
			} // end of condition for g_Main.m_DCLParser.HasErrorOccured() = FALSE

  >>
	(colonStatement[2]>[pTempTreeNode])*  
  )	
  <<
	// deletion / deallocation
  >>

;


referenceStatement  //reference statements
	:
	 <<
		// declarations 
		TreeNode *pTempTreeNode = NULL;
	 >>
	
	colonStatement[1] >[pTempTreeNode]
		<<	

		/***************************************************************************************
		*       This condition is met whenever a tile is referenced.The referenced tile must be
		*  within a tile which is a container.Otherwise an error is written to the error log.
		* 
		*  Here "pTempTreeNode" is mewly created TreeNode returned from the colon(:) statement rule
		*
		*/

	if ( g_Main.m_DCLParser.HasErrorOccured() == FALSE )
		{
		// validation for reference
		  	
		ASSERT(m_pCurrentTreeNode); 
            
		// check whether the parent node is complete before checking whether 
		// it is a container
		if ( m_pCurrentTreeNode->m_bIsComplete == TRUE )
			{   
			// if parent is container then add the child,or else  
			// write the error to the error log
			if ( m_pCurrentTreeNode->m_Tile.IsContainer())
				{
				m_pCurrentTreeNode->AddChild(pTempTreeNode);
				m_pCurrentTreeNode = pTempTreeNode;
				} 
			else
				{
				// Error Handling

				lstNonContianerNodes.AddTail(m_pCurrentTreeNode);  				
                g_Main.m_DCLParser.set_NonContianerContains();
                m_pCurrentTreeNode->AddChild(pTempTreeNode);

				m_pCurrentTreeNode = pTempTreeNode;

//				delete pTempTreeNode;
					            
				} // end of conditon else for bContainer = TRUE
			}   
		else
			{   
			// added the new tree node to the current node, and 
			// make the new node the current node 
			m_pCurrentTreeNode->AddChild(pTempTreeNode);
			m_pCurrentTreeNode = pTempTreeNode;
			}

		}//end of conditon for g_Main.m_DCLParser.HasErrorOccured() = FALSE
        
		

		>>
    (colonStatement[2]>[pTempTreeNode])*
	;
     


assignmentStatement // Create attrib-value pair & store in current parent   
	: 
	<<
	    //declarations
		static CString wszAttributeName;    // used to store the name of the attribute
		static CString wszAttributeValue;   // used to store the value of the attribute
		TileAttributes *pTempTileAttribute; // holds the name,type and value of attribute set  
	>> 
	
     (ATTRIBUTES << wszAttributeName = $1->getText(); >> 	
	  |IDENT     << wszAttributeName = $1->getText(); >> 	
	 ) 
	 EQUALS
	 (constantValue[wszAttributeName]
	  | ATTRIB_VALUES // Pre defined attribute values like true, false etc.
		<< 
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{
			// attributes set here
			wszAttributeValue = $1->getText();
			pTempTileAttribute = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
			if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
				{
				TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
				lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
				lstNodesWithErrors.AddTail(pTemp);
				} 
				AuditLevelProcessor audlvl;
				TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
				if ( audlvl.CheckForRedundancy(pTemp) == SDS_RTERROR )
					{
					lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
					lstNodesWithErrors.AddTail(pTemp);
					}
			    else
					{
					delete pTemp;
					}

			
       		}

		>>	
	  )
	<<
		//deletion carried on here
	>> 
	;


constantValue[CString& wszAttributeName]
    : <<
       // declarations
	   static CString wszAttributeValue;      // Used to set the attribute values and passs the
	   TileAttributes *pTempTileAttribute;	  // pointer to  a TileAttribute class object.
	   
	  >>

   (INTLIT 
	 << 
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{ 
			// initailization of integer value
			wszAttributeValue = $1->getText();
			pTempTileAttribute = new TileAttributes(wszAttributeName,_T("1"),wszAttributeValue);
			if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
				{
				g_Main.m_DCLParser.set_HintCount();
				TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("1"),wszAttributeValue);
				lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
				lstNodesWithErrors.AddTail(pTemp);
				}
			}

	 >> 
		     
	 | REAL_LIT  
	  << 
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{
			// initailization of float value
			wszAttributeValue = $1->getText();
			pTempTileAttribute = new TileAttributes(wszAttributeName,_T("2"),wszAttributeValue);
			if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
				{
				TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("2"),wszAttributeValue);
				lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
				lstNodesWithErrors.AddTail(pTemp);
				}
			}
	  >>
		  
	 | STRING_LITERAL 
	  << 
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{
			// initialization of string value  
			wszAttributeValue = $1->getText();
			pTempTileAttribute = new TileAttributes(wszAttributeName,_T("3"),wszAttributeValue);
			ASSERT(pTempTileAttribute);
			if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
				{
				TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("3"),wszAttributeValue);
				lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
				lstNodesWithErrors.AddTail(pTemp);
				}
			

			}

	  >> 
	
	 | IDENT  
		<<
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{ 
			// initialization of identifier value  
			wszAttributeValue = $1->getText();
			pTempTileAttribute = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
			ASSERT(pTempTileAttribute);
			if ( m_pCurrentTreeNode->m_Tile.AddAttributes(pTempTileAttribute,0) == SDS_RTERROR )
				{
				TileAttributes *pTemp = new TileAttributes(wszAttributeName,_T("4"),wszAttributeValue);
				lstNodesWithErrors.AddTail(m_pCurrentTreeNode);  
				lstNodesWithErrors.AddTail(pTemp);
				}
			}
		 
		>>  
	)
		
	<<
		// deletion
	>>	 
	;

colonStatement[int nOccurance] > [TreeNode *pNewTreeNode ]
	: 
		<<
		    // declarations
			static CString wszTileName;     // holds the tile name
			Tile *pTile = NULL;             // holds the pointer to the referenced tile
			TreeNode *pTempTreeNode = NULL ;    // holds the pointer to a node created
			TreeNode *pReferencedNode = NULL;   //points to the node being referenced  
		    int nResult = 0;                    // to store return value of functions  
			
		>>
	  
	  COLON 
	  (TILES <<  wszTileName = $1->getText(); >>
	  | IDENT <<  wszTileName = $1->getText(); >>
	  | BASE_BLOCKS <<  wszTileName = $1->getText(); >>
	  )
	  << 
	   /****************************************************************************************
	   *       This condition is called whenever a  " :reference " statement is found.
	   *  It accepts a input value  
	   *   0 - when condition called from protypes
	   *   1 - when condition called from reference statements
	   *   2 - for multiple references 
	   */  
	    
		if (g_Main.m_DCLParser.HasErrorOccured() == FALSE)
			{	
			// tree generation
			$pNewTreeNode = NULL ;
 		    nResult = SDS_RTNORM;

			//find reference and clone the node if reference is in the first level
			if ($nOccurance == 1 || $nOccurance == 0) 
				{
				if (wszTileName == _T("dialog"))
					{
    				nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,2,&pReferencedNode);
					}
				else
					{ 
					nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,1,&pReferencedNode);
					}
				}

			//if reference found
			if (nResult == SDS_RTNORM) 
				{
				if ($nOccurance == 1 || $nOccurance == 0) 
					{ 
					pTempTreeNode = new TreeNode ;
											   
					if (pTempTreeNode->m_Tile.IsRenderable(wszTileName))
						{
		  				pTempTreeNode->m_Tile.set_RenderableTileName(wszTileName) ; 
						}

					pTempTreeNode->m_Tile.set_TileName(wszTileName);  				

					pTempTreeNode->m_Tile.CopyAttributes(wszErrorInFunc,pReferencedNode->m_Tile,0); 
					$pNewTreeNode = pTempTreeNode ;
					} 
				else if  ( $nOccurance == 2 ) //this condition met for multiple reference
					{
					// code for multiple references 

					//add referenced tile to list
					m_pCurrentTreeNode->m_Tile.AddReferencedTile(wszTileName);
					if ( m_pCurrentTreeNode->m_Tile.GetTileNameToBeCloned() == wszTileName ) 
						{												
						if (wszTileName == _T("dialog"))
							{  
    						nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,2,&pReferencedNode);
							}
						else 
							{  
							nResult = g_Main.m_DCLParser.FindReferencedNode(wszTileName,1,&pReferencedNode);
							}
						}
					else  
						{
						nResult = SDS_RTERROR;
						}

       
					//if reference found
					if ( nResult == SDS_RTNORM )
						{
						ASSERT(m_pCurrentTreeNode);
						m_pCurrentTreeNode->m_Tile.CopyAttributes(wszErrorInFunc,pReferencedNode->m_Tile,2);
						}
					else
						{
           
						//if	reference not found then add to non-defined list
						NonDefinedNode *pTempNonDefinedNode = new NonDefinedNode(
																			 m_pFileInfo->get_DCLFileName(),		
																			 LT(1)->getLine(),
																			 2,
																			 m_pCurrentTreeNode,
																			 wszTileName);				
																					  

						//add the nondefined node to the list of nondefined nodes
						g_Main.m_DCLParser.AddNonDefinedNode(pTempNonDefinedNode);

						/* if any code for
								a) non defined in function startstatement   
								b) in reference statement
						*/	

						}     
			            			  
					}//end of else if  for $nOccurance == 2
				}//end of condition for nResult == SDS_RTNORM 
			else
				{
				//add code for undefined nodes
				pTempTreeNode = new TreeNode ; 	 
				pTempTreeNode->m_Tile.AddReferencedTile(wszTileName);
				pTempTreeNode->m_Tile.set_TileName(wszTileName);
				$pNewTreeNode = pTempTreeNode ;
        
				NonDefinedNode *pTempNonDefinedNode = new NonDefinedNode(
																	m_pFileInfo->get_DCLFileName(),		 
																	LT(1)->getLine(),
																	1,
																	pTempTreeNode,
																	wszTileName);
									 
				pTempTreeNode->m_bIsComplete = FALSE;


				//add the nondefined node to the list of nondefined nodes
				g_Main.m_DCLParser.AddNonDefinedNode(pTempNonDefinedNode);

				/* if any code for
						a) non defined in function startstatement   
						b) in reference statement
				*/

				$pNewTreeNode = pTempTreeNode ;
     			}//end of condtion for nondefined node

			}//end of condition for g_Main.m_DCLParser.HasErrorOccured() == FALSE		         
			  
	  >>
	
	  << 
	     // delete
            
	  >>	
	;
}





