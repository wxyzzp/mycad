// Wrapper class(es) generated by Dynamo!
// This file was generated at 17:58:23 on 05/06/1997
// by DynamoCL - Version 1.04
/******************************************************************************/

//
// D:\VSPELL\VSPLWRAP\VSPEwrap.h - C++ Wrappers for Type Library "VSPELLLib"
// Copyright (C) 1996 Visio Corporation. All rights reserved.
//

/******************************************************************************/
//  'Sentinel'

#ifndef _VSPEwrap_H
#define _VSPEwrap_H

#define _VSPELLLib_WRAPPERS
#define _VSPELLLib_WRAPPERS_VERSION 0x00010000

/******************************************************************************/
//  Contents of header.h



/******************************************************************************/
//  Macros

#ifndef VW_INTERFACE_NOT_SET
#define VW_INTERFACE_NOT_SET    MAKE_HRESULT(SEVERITY_ERROR, 0x06a5, 0x4001);
#endif  //  VW_INTERFACE_NOT_SET

#ifndef CHECK_IP
#define CHECK_IP(ip, className, methName)
#endif  //  CHECK_IP

#ifndef CHECK_HRESULT
#define CHECK_HRESULT(hr, className, methName)
#endif  //  CHECK_HRESULT

#ifndef VW_CONST
#define VW_CONST const
#endif  //  VW_CONST

#ifndef VW_INLINE
#define VW_INLINE inline
#endif  //  VW_INLINE

#ifndef FAR
#define FAR
#endif  //  FAR

#ifndef VW_PUBLIC
#define VW_PUBLIC public
#endif  //  VW_PUBLIC

#ifndef VW_PROTECTED
#define VW_PROTECTED protected
#endif  //  VW_PROTECTED

#ifndef VW_PRIVATE
#define VW_PRIVATE private
#endif  //  VW_PRIVATE


/******************************************************************************/
//  Forward declarations and typedefs

class FAR CVSpellUnknown;

class FAR CVSpell;


#ifndef VSPELLLIB_LPS_FORWARD_DECLARED
#define VSPELLLIB_LPS_FORWARD_DECLARED

interface IVSpell;
typedef IVSpell FAR *LPVSPELLLIBIVSPELL;

#endif  //  VSPELLLIB_LPS_FORWARD_DECLARED


/******************************************************************************/
//  Root class declaration

class FAR CVSpellUnknown
{
VW_PUBLIC:
    CVSpellUnknown() { m_pUnk= NULL; }

    CVSpellUnknown(const CVSpellUnknown FAR &other)
        {
        m_pUnk= NULL;
        CopyIP(other.GetUnknown());
        }

    CVSpellUnknown(LPUNKNOWN lpIUnk)
        {
        m_pUnk= NULL;
        CopyIP(lpIUnk);
        }

    const CVSpellUnknown FAR & operator=(const CVSpellUnknown FAR &other)
        {
        if ( &other != this )
            CopyIP(other.GetUnknown());

        return *this;
        }

    const CVSpellUnknown FAR & operator=(const LPUNKNOWN other)
        {
        if ( other != GetUnknown() )
            CopyIP(other);

        return *this;
        }

    virtual ~CVSpellUnknown() { ReleaseIP(); }

    virtual BOOL IsSet() const { return ((NULL == GetUnknown()) ? FALSE : TRUE); }

    virtual UINT RefCount() const
        {
        UINT uc= 0xFFFFFFFF;    //  probably means m_pUnk==NULL
        if (NULL!=m_pUnk)
            {
            m_pUnk->AddRef();
            uc= m_pUnk->Release();
            }
        return uc;
        }

VW_PROTECTED:
    void AddRefIP()
        {
        if ( NULL != m_pUnk )
            m_pUnk->AddRef();
        }

    void ReleaseIP()
        {
        if ( NULL != m_pUnk )
            {
            m_pUnk->Release();
            m_pUnk = NULL;
            }
        }

    void CopyIP(LPUNKNOWN lpIUnk)
        {
        ReleaseIP();
        m_pUnk = lpIUnk;
        AddRefIP();
        }

    LPUNKNOWN GetUnknown() const
        {
        //  NO AddRef
        return m_pUnk;
        }

VW_PRIVATE:
    LPUNKNOWN m_pUnk;
};


/******************************************************************************/
//  TypeLib Interface class declarations


/******************************************************************************/
//  Declaration of class CVSpell

class FAR CVSpell : public CVSpellUnknown
{
VW_PUBLIC:
    CVSpell()
        : CVSpellUnknown() { }

    CVSpell(const CVSpell& other)
        : CVSpellUnknown(other) { }

    CVSpell(const IVSpell FAR * other)
        : CVSpellUnknown((LPUNKNOWN)other) { }

    const CVSpell FAR & operator=(const CVSpell FAR &other)
        {
        if ( &other != this )
            CopyIP(other.GetUnknown());

        return *this;
        }

    const CVSpell FAR & operator=(const IVSpell FAR * other)
        {
        if ( (LPUNKNOWN)other != GetUnknown() )
            CopyIP((LPUNKNOWN)other);

        return *this;
        }

    virtual ~CVSpell() { }

    IVSpell FAR * GetIP() const { return (IVSpell FAR *) GetUnknown(); }

    operator IVSpell FAR * () { return (IVSpell FAR *) GetUnknown(); }

VW_PUBLIC:
    HRESULT Init(long bIgnoreNum, unsigned long lcLocale, char *lpszEnginePath, char *lpszDicPath);
    HRESULT Spell(char *lpszWord, unsigned short FAR *lpwResult);
    HRESULT Suggest(char *lpszWord, char *lpszSuggestions, unsigned long FAR *lpdwNumSuggestions, unsigned long dwSuggestionBufLen, unsigned short FAR *lpwResult);
    HRESULT IgnoreAll(char *lpszIgnoreThis, unsigned short FAR *lpwResult);
    HRESULT LoadUserDictionary(char *lpszDicPath, unsigned short FAR *lpwResult);
    HRESULT UnloadUserDictionary(char *lpszDicPath);
    HRESULT AddToUserDictionary(char *lpszDicPath, char *lpszAddThis, unsigned short FAR *lpwResult);
    HRESULT AddUnsupportedLocale(unsigned long lcLocale);
    HRESULT IsLocaleSupported(unsigned long lcLocale, BOOL FAR *lpbSupported);
    HRESULT ChangeLocale(unsigned long lcLocale, char *lpszDicPath);
    HRESULT GetLocale(unsigned long FAR *lplcLocale);
};


/******************************************************************************/
//  TypeLib Interface class implementations

/******************************************************************************/
//  Implementation of class CVSpell

VW_INLINE HRESULT CVSpell::Init(long bIgnoreNum, unsigned long lcLocale, char *lpszEnginePath, char *lpszDicPath)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, Init);
    if (NULL!=GetIP())
        hr= GetIP()->Init(bIgnoreNum, lcLocale, lpszEnginePath, lpszDicPath);
    CHECK_HRESULT(hr, CVSpell, Init);
    return hr;
}


VW_INLINE HRESULT CVSpell::Spell(char *lpszWord, unsigned short FAR *lpwResult)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, Spell);
    if (NULL!=GetIP())
        hr= GetIP()->Spell(lpszWord, lpwResult);
    CHECK_HRESULT(hr, CVSpell, Spell);
    return hr;
}


VW_INLINE HRESULT CVSpell::Suggest(char *lpszWord, char *lpszSuggestions, unsigned long FAR *lpdwNumSuggestions, unsigned long dwSuggestionBufLen, unsigned short FAR *lpwResult)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, Suggest);
    if (NULL!=GetIP())
        hr= GetIP()->Suggest(lpszWord, lpszSuggestions, lpdwNumSuggestions, dwSuggestionBufLen, lpwResult);
    CHECK_HRESULT(hr, CVSpell, Suggest);
    return hr;
}


VW_INLINE HRESULT CVSpell::IgnoreAll(char *lpszIgnoreThis, unsigned short FAR *lpwResult)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, IgnoreAll);
    if (NULL!=GetIP())
        hr= GetIP()->IgnoreAll(lpszIgnoreThis, lpwResult);
    CHECK_HRESULT(hr, CVSpell, IgnoreAll);
    return hr;
}


VW_INLINE HRESULT CVSpell::LoadUserDictionary(char *lpszDicPath, unsigned short FAR *lpwResult)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, LoadUserDictionary);
    if (NULL!=GetIP())
        hr= GetIP()->LoadUserDictionary(lpszDicPath, lpwResult);
    CHECK_HRESULT(hr, CVSpell, LoadUserDictionary);
    return hr;
}


VW_INLINE HRESULT CVSpell::UnloadUserDictionary(char *lpszDicPath)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, UnloadUserDictionary);
    if (NULL!=GetIP())
        hr= GetIP()->UnloadUserDictionary(lpszDicPath);
    CHECK_HRESULT(hr, CVSpell, UnloadUserDictionary);
    return hr;
}


VW_INLINE HRESULT CVSpell::AddToUserDictionary(char *lpszDicPath, char *lpszAddThis, unsigned short FAR *lpwResult)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, AddToUserDictionary);
    if (NULL!=GetIP())
        hr= GetIP()->AddToUserDictionary(lpszDicPath, lpszAddThis, lpwResult);
    CHECK_HRESULT(hr, CVSpell, AddToUserDictionary);
    return hr;
}


VW_INLINE HRESULT CVSpell::AddUnsupportedLocale(unsigned long lcLocale)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, AddUnsupportedLocale);
    if (NULL!=GetIP())
        hr= GetIP()->AddUnsupportedLocale(lcLocale);
    CHECK_HRESULT(hr, CVSpell, AddUnsupportedLocale);
    return hr;
}


VW_INLINE HRESULT CVSpell::IsLocaleSupported(unsigned long lcLocale, BOOL FAR *lpbSupported)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, IsLocaleSupported);
    if (NULL!=GetIP())
        hr= GetIP()->IsLocaleSupported(lcLocale, lpbSupported);
    CHECK_HRESULT(hr, CVSpell, IsLocaleSupported);
    return hr;
}


VW_INLINE HRESULT CVSpell::ChangeLocale(unsigned long lcLocale, char *lpszDicPath)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, ChangeLocale);
    if (NULL!=GetIP())
        hr= GetIP()->ChangeLocale(lcLocale, lpszDicPath);
    CHECK_HRESULT(hr, CVSpell, ChangeLocale);
    return hr;
}


VW_INLINE HRESULT CVSpell::GetLocale(unsigned long FAR *lplcLocale)
{
    HRESULT hr= VW_INTERFACE_NOT_SET;
    CHECK_IP(GetIP(), CVSpell, GetLocale);
    if (NULL!=GetIP())
        hr= GetIP()->GetLocale(lplcLocale);
    CHECK_HRESULT(hr, CVSpell, GetLocale);
    return hr;
}



/******************************************************************************/
//  'Trailer'
#define VSPL_NOERR 0
#define VSPL_INDIC VSPL_NOERR
#define VSPL_NOTINDIC 1
#define VSPL_MOREALTS 2
#define VSPL_LANGNS 3
#define VSPL_ERR 4
#define VSPL_LANGERR 5
#define VSPL_FILEERR 6
#define VSPL_INITERR 7


/******************************************************************************/
//  #endif for 'Sentinel'

#endif /* _VSPEwrap_H */
