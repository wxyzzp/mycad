///////////////////////////////////////////////////////////////////////////////
// Copyright © 2002, Open Design Alliance Inc. ("Open Design") 
// 
// This software is owned by Open Design, and may only be incorporated into 
// application programs owned by members of Open Design subject to a signed 
// Membership Agreement and Supplemental Software License Agreement with 
// Open Design. The structure and organization of this Software are the valuable 
// trade secrets of Open Design and its suppliers. The Software is also protected 
// by copyright law and international treaty provisions. You agree not to 
// modify, adapt, translate, reverse engineer, decompile, disassemble or 
// otherwise attempt to discover the source code of the Software. Application 
// programs incorporating this software must include the following statment 
// with their copyright notices:
//
//      DWGdirect © 2002 by Open Design Alliance Inc. All rights reserved. 
//
// By use of this software, you acknowledge and accept the terms of this 
// agreement.
///////////////////////////////////////////////////////////////////////////////



#ifndef OD_GETORUS_H
#define OD_GETORUS_H


#include "GeSurface.h"
#include "GeCircArc3d.h"
#include "OdPlatform.h"

#include "DD_PackPush.h"

/** Description:   
    A representation for a torus, a surface generated by revolving a circular
    arc about an axis of symmetry, where the plane of the arc is a plane
    containing the axis of symmetry
    
    Remarks:
    The torus is located in space by its
    origin which is a point on the axis of symetry.  The locus of the
    center of the circular arc is at a distance of majorRadius from
    the origin of the torus. The radius of the circular arc is the
    minorRadius.
    Parameter u is the longitude, which for a closed torus defaults
    to the range [-PI, PI).  Zero corresponds to the refAxis (which is
    a vector orthogonal to the axis of symetry).  Applying the right
    hand rule along the symetric axis defines the increasing direction
    for u.
    Parameter v parameterizes the circular arc (of revolution), which
    for a closed circle defaults to the range [-PI, PI).  Applying the
    right hand rule along the refAxis X symetricAxis defines the
    increasing direction for v.
    The torus is periodic in u, v with a period of 2PI.
    [umin, umax] x [vmin, vmax] defines a four sided toroidal patch bounded
    by four circular arcs. Following constraints apply to the definition
    of a toroidal patch.
    umin < umax and |umin - umax| <= 2PI.
    vmin < vmax and |vmin - vmax| <= 2PI
    
    {group:OdGe_Classes} 
*/
class GE_TOOLKIT_EXPORT OdGeTorus : public OdGeSurface
{
public:
  OdGeTorus();
  OdGeTorus(double majorRadius, double minorRadius,
            const OdGePoint3d& origin, const OdGeVector3d& axisOfSymmetry);
  OdGeTorus(double majorRadius, double minorRadius,
            const OdGePoint3d&  origin, const OdGeVector3d& axisOfSymmetry,
            const OdGeVector3d& refAxis,
            double startAngleU, double endAngleU,
            double startAngleV, double endAngleV);
  OdGeTorus(const OdGeTorus& torus);

  virtual OdGeEntity3d* copy() const;

  // OdGeEntity3d functions
  virtual bool isKindOf(OdGe::EntityId entType) const;
  virtual OdGe::EntityId type() const;
  // OdGeSurface functions
  virtual void getEnvelope (OdGeInterval& intrvlX, OdGeInterval& intrvlY) const;
  virtual bool isClosedInU (const OdGeTol& tol = OdGeContext::gTol) const;
  virtual bool isClosedInV (const OdGeTol& tol = OdGeContext::gTol) const;

  // Geometric properties.
  //
  double          majorRadius    () const;
  double          minorRadius    () const;
  void            getAnglesInU   (double& start, double& end) const;
  void            getAnglesInV   (double& start, double& end) const;
  OdGePoint3d     center         () const;
  OdGeVector3d    axisOfSymmetry  () const;
  OdGeVector3d    refAxis        () const;
  bool  isOuterNormal  () const;

  OdGeTorus&      setMajorRadius (double radius);
  OdGeTorus&      setMinorRadius (double radius);
  OdGeTorus&      setAnglesInU   (double start, double end);
  OdGeTorus&      setAnglesInV   (double start, double end);
  inline OdGeTorus&      set     (double majorRadius, double minorRadius,
                                  const OdGePoint3d& origin,
                                  const OdGeVector3d& axisOfSymmetry);
  OdGeTorus&      set            (double majorRadius, double minorRadius,
                                  const OdGePoint3d&  origin,
                                  const OdGeVector3d& axisOfSymmetry,
                                  const OdGeVector3d& refAxis,
                                  double startAngleU, double endAngleU,
                                  double startAngleV, double endAngleV);
  // Shape Classification Functions
  bool isApple() const;
  bool isDegenerate() const;
  bool isDoughnut() const;
  bool isHollow() const;
  bool isLemon() const;
  bool isVortex() const;

  // Assignment operator.
  //
  inline OdGeTorus&      operator =     (const OdGeTorus& torus);

  // Intersection with a linear entity
  //
  bool  intersectWith  (const OdGeLinearEnt3d& linEnt, int& intn,
                                  OdGePoint3d& p1, OdGePoint3d& p2,
                                  OdGePoint3d& p3, OdGePoint3d& p4,
                                  const OdGeTol& tol = OdGeContext::gTol) const;

  virtual OdGePoint2d paramOf(const OdGePoint3d& pnt,
    const OdGeTol& tol = OdGeContext::gTol) const;

  virtual OdGePoint3d evalPoint(const OdGePoint2d& param) const;
  virtual OdGePoint3d evalPoint(const OdGePoint2d& param, int derivOrd,
    OdGeVector3dArray& derivatives, OdGeVector3d& normal) const;


  DD_USING(OdGeSurface::evalPoint);

protected:
  OdGeCircArc3d m_vArc;
  double        m_minorRadius;
  double        m_startAngleU;
  double        m_endAngleU;
};

//////////////////////////////////////////////////////////////////////////////
inline OdGeTorus::OdGeTorus()
    : m_minorRadius(0.5)
{
  setAnglesInU(-OdaPI, OdaPI);
  setAnglesInV(-OdaPI, OdaPI);
}

inline OdGeTorus::OdGeTorus(double majorRadius, double minorRadius,
              const OdGePoint3d& origin, const OdGeVector3d& axisOfSymmetry)
{
  set(majorRadius, minorRadius, origin, axisOfSymmetry);
}

inline OdGeTorus::OdGeTorus(double majorRadius, double minorRadius,
              const OdGePoint3d&  origin, const OdGeVector3d& axisOfSymmetry,
              const OdGeVector3d& refAxis,
              double startAngleU, double endAngleU,
              double startAngleV, double endAngleV)
{
  set(majorRadius, minorRadius, origin, axisOfSymmetry,
      refAxis, startAngleU, endAngleU,
      startAngleV, endAngleV);
}

inline OdGeTorus::OdGeTorus(const OdGeTorus& torus)
{
  operator = (torus);
}

    // Geometric properties.
    //
inline double          OdGeTorus::majorRadius    () const
{ return m_vArc.radius();}

inline double          OdGeTorus::minorRadius    () const
{ 
  if (isNormalReversed())
    return -m_minorRadius;
  return m_minorRadius;
}

inline OdGePoint3d     OdGeTorus::center         () const
{ return m_vArc.center();}

inline OdGeVector3d    OdGeTorus::axisOfSymmetry  () const
{ return m_vArc.normal();}

inline OdGeVector3d    OdGeTorus::refAxis        () const
{ return m_vArc.refVec();}

inline OdGeTorus&      OdGeTorus::setMajorRadius (double radius)
{ m_vArc.setRadius(radius);  return *this;}

inline OdGeTorus&      OdGeTorus::setMinorRadius (double radius)
{ m_minorRadius = radius; return *this;}

inline OdGeTorus& OdGeTorus::set(double majorRadius, double minorRadius,
                                 const OdGePoint3d& origin,
                                 const OdGeVector3d& axisOfSymmetry)
{
  m_vArc.set(origin, axisOfSymmetry, majorRadius);
  m_minorRadius = minorRadius;
  setAnglesInU(-OdaPI, OdaPI);
  setAnglesInV(-OdaPI, OdaPI);
  return *this;
}
    // Assignment operator.
    //
inline OdGeTorus& OdGeTorus::operator = (const OdGeTorus& torus)
{
  m_vArc = torus.m_vArc;
  m_minorRadius = torus.m_minorRadius;
  m_startAngleU = torus.m_startAngleU;
  m_endAngleU = torus.m_endAngleU;
  return *this;
}

#include "DD_PackPop.h"

#endif // OD_GETORUS_H


