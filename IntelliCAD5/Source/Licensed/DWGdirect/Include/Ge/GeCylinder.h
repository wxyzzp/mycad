///////////////////////////////////////////////////////////////////////////////
// Copyright © 2002, Open Design Alliance Inc. ("Open Design") 
// 
// This software is owned by Open Design, and may only be incorporated into 
// application programs owned by members of Open Design subject to a signed 
// Membership Agreement and Supplemental Software License Agreement with 
// Open Design. The structure and organization of this Software are the valuable 
// trade secrets of Open Design and its suppliers. The Software is also protected 
// by copyright law and international treaty provisions. You agree not to 
// modify, adapt, translate, reverse engineer, decompile, disassemble or 
// otherwise attempt to discover the source code of the Software. Application 
// programs incorporating this software must include the following statment 
// with their copyright notices:
//
//      DWGdirect © 2002 by Open Design Alliance Inc. All rights reserved. 
//
// By use of this software, you acknowledge and accept the terms of this 
// agreement.
///////////////////////////////////////////////////////////////////////////////



#ifndef OD_GECYLNDR_H
#define OD_GECYLNDR_H



#include "OdPlatformSettings.h"
#include "GeSurface.h"
#include "GeInterval.h"

class OdGeCircArc3d;

#include "DD_PackPush.h"

/** Description: 
    A representation for a right circular cylinder.  
    
    Remarks:
    It is defined by its radius, axis of symmetry, 
    and the origin (a point on the axis). It
    is generated by revolving a line parallel to the axis of symmetry,
    at a  distance of radius. The cylinder is paramterized as follows.
    u is the angle of revolution, measured from the refAxis (an axis
    perpendicular to the axis of symmetry). Right hand rule applied
    along the direction of the axis of symmetry defines the positive
    direction.  For a closed cylinder, u defaults to [-PI, PI).
    v parameter varies along the axis of symmetry.  It is positive in
    the direction of the axis of symmetry.  v = 0 correspond to the
    cross section containing the origin of the cylinder.  v is
    dimensionless.  Its speed is determined by the initial radius
    of the cylinder.

    The surface is perodic in u with a period of 2PI.
    [umin, umax] x [vmin, vmax] defines a four sided cylindrical
    patch bounded by two straight lines (at umin and umax), and
    two circular arcs (at vmin and vmax).  Following constraints
    apply to the definition of a cylindrical patch.
    umin < umax and |umin - umax| <= 2PI.
    
    {group:OdGe_Classes} 
*/
class GE_TOOLKIT_EXPORT OdGeCylinder : public OdGeSurface
{
public:
  OdGeCylinder();
  OdGeCylinder(double radius, const OdGePoint3d& origin,
               const OdGeVector3d& axisOfSymmetry);
  OdGeCylinder(double radius, const OdGePoint3d& origin,
               const OdGeVector3d& axisOfSymmetry,
               const OdGeVector3d& refAxis,
               const OdGeInterval& height,
               double startAngle, double endAngle);
  
  // Run time type information.
  bool isKindOf(OdGe::EntityId entType) const;
  OdGe::EntityId type() const;

  virtual OdGePoint2d paramOf(const OdGePoint3d& pnt,
    const OdGeTol& tol = OdGeContext::gTol) const;

  virtual OdGePoint3d evalPoint(const OdGePoint2d& param) const;
  virtual OdGePoint3d evalPoint(const OdGePoint2d& param, int derivOrd,
    OdGeVector3dArray& derivatives, OdGeVector3d& normal) const;

  DD_USING(OdGeSurface::evalPoint);

  // Make a copy of the entity.
  OdGeEntity3d* copy() const;

  // Geometric properties.
  //
  double         radius        () const;
  OdGePoint3d    origin        () const;
  void           getAngles     (double& start, double& end) const;
  void           getHeight     (OdGeInterval& height) const;
  double         heightAt      (double u) const;
  OdGeVector3d   axisOfSymmetry() const;
  OdGeVector3d   refAxis       () const;
  bool           isOuterNormal  () const;
  bool           isClosed      (const OdGeTol& tol = OdGeContext::gTol) const;
  bool           isClosedInU   (const OdGeTol& tol = OdGeContext::gTol) const;
  bool           isClosedInV   (const OdGeTol& tol = OdGeContext::gTol) const;

  void           setIsOuterNormal(bool isOuterNormal);
  OdGeCylinder&  setRadius     (double radius);
  OdGeCylinder&  setAngles     (double start, double end);
  OdGeCylinder&  setHeight     (const OdGeInterval& height);
  OdGeCylinder&  set           (double radius, const OdGePoint3d& origin, const OdGeVector3d& axisOfSym);
  OdGeCylinder&  set           (double radius, const OdGePoint3d& origin,
                                const OdGeVector3d& axisOfSym,
                                const OdGeVector3d& refAxis,
                                const OdGeInterval& height,
                                double startAngle, double endAngle);
  // Assignment operator.
  //
  //OdGeCylinder&  operator =    (const OdGeCylinder& cylinder);
  
  // Intersection with a linear entity
  //
  bool intersectWith (const OdGeLinearEnt3d& linEnt, int& intn,
                                OdGePoint3d& p1, OdGePoint3d& p2,
                                const OdGeTol& tol = OdGeContext::gTol) const;

  void getEnvelope(OdGeInterval& intrvlU, OdGeInterval& intrvlV) const;

  virtual bool project(const OdGePoint3d& p, OdGePoint3d& projP) const;
  
private:
  double        m_radius,
                m_startAngle,
                m_endAngle;
  OdGeInterval  m_height;
  OdGeVector3d  m_axisOfSymmetry;
  OdGeVector3d  m_refAxis;
  OdGePoint3d   m_origin;
};

inline OdGePoint3d OdGeCylinder::origin() const { return m_origin; }

inline void OdGeCylinder::getAngles(double& start, double& end) const
{ start = m_startAngle; end = m_endAngle; }

inline void OdGeCylinder::getHeight(OdGeInterval& range) const 
{ 
  range = m_height;
}

inline double OdGeCylinder::heightAt(double u) const
{
  return fabs(m_radius) * u;
}

inline OdGeVector3d OdGeCylinder::axisOfSymmetry() const { return m_axisOfSymmetry; }

inline OdGeVector3d OdGeCylinder::refAxis() const { return m_refAxis; }

inline bool OdGeCylinder::isClosed(const OdGeTol&) const
{ return OdCmpDouble(m_endAngle - m_startAngle, 2.0 * OdaPI) != -1; }

#include "DD_PackPop.h"

#endif // OD_GECYLNDR_H

